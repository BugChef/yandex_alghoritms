"""
ID = 50196175

Решение такое:
Сначала нужно проверить, что сумма четная, так как
дробное число из целых не собрать.
Ищем элементы, которые сформируют сумму sum / 2, так как
если найдем такие, то сумма оставшихся так же будет равна sum / 2.
Массив part дает информацию, можно ли из представленных чисел получить part[i].
Проходимся 2умя циклами и расставляем part, я там в коде написал коммент,
как раставляются значения в part

Сложность алгоритма O(sum * n), где sum это сумма элементов массива
Дополнительная память нужна только для хранения массива part O(sum)
"""


def find_splits(arr, n) -> bool:
    sm = sum(arr)

    if sm % 2 != 0:
        return False

    part = [False] * ((sm // 2) + 1)

    for i in range(n):
        for j in range(sm // 2, arr[i] - 1, -1):
            # part[j - arr[i]] означает, что sum - arr[i] может
            # быть сформирован из чисел до индекса i
            # j == arr[i] означает, что число можно сформировать из самого себя
            if part[j - arr[i]] or j == arr[i]:
                part[j] = True
    return part[sm // 2]


n = int(input())
arr = [int(x) for x in input().split()]
can_split = find_splits(arr, n)
print("True" if can_split else "False")
